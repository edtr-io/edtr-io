## API Report File for "@edtr-io/plugin"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { PluginProps } from '@edtr-io/internal__plugin-state';
import * as React from 'react';
import { StateExecutor } from '@edtr-io/internal__plugin-state';
import { StateType } from '@edtr-io/internal__plugin-state';
import { StateTypesReturnType } from '@edtr-io/internal__plugin-state';
import { StateTypesSerializedType } from '@edtr-io/internal__plugin-state';
import { StateTypesValueType } from '@edtr-io/internal__plugin-state';

// @public (undocumented)
export function asyncScalar<T, Temp>(initial: T, isTemporaryValue: (field: T | Temp) => boolean): StateType<T, T | Temp, {
    value: T | Temp;
    get(): T | Temp;
    set(initial: T | Temp | ((previousValue: T | Temp) => T | Temp), executor?: StateExecutor<T | Temp | ((previousValue: T | Temp) => T | Temp)>): void;
}>;

// @public (undocumented)
export function boolean(initialValue?: boolean): StateType<boolean, boolean, {
    value: boolean;
    get(): boolean;
    set(value: boolean | ((currentValue: boolean) => boolean)): void;
}>;

// @public (undocumented)
export function child<K extends string, S = unknown>({ plugin, initialState, config }?: {
    plugin?: K;
    initialState?: S;
    config?: {};
}): StateType<{
    plugin: K;
    state?: S;
}, string, {
    get(): string;
    id: string;
    render: (props?: PluginProps) => React.ReactNode;
    replace: (plugin?: K, state?: S) => void;
}>;

// @public (undocumented)
export type FileState<T> = T | TempFile;

// @public (undocumented)
export function isTempFile<T>(state: FileState<T>): state is TempFile;

// @public (undocumented)
export function list<S, T = S, U = unknown>(type: StateType<S, T, U>, initialCount?: number): StateType<S[], {
    id: string;
    value: T;
}[], U[] & {
    set(updater: (currentList: T[], deserialize: (serialized: S) => T) => T[]): void;
    insert(index?: number, options?: S): void;
    remove(index: number): void;
    move(from: number, to: number): void;
}>;

// @public (undocumented)
export interface LoadedFile {
    // (undocumented)
    dataUrl: string;
    // (undocumented)
    file: File;
}

// @public (undocumented)
export function migratable<S, T, R>(type: StateType<S, T, R>): MigratableStateType<S, S, S, T, R>;

// @public (undocumented)
export interface MigratableStateType<InitialS, AllS, S, T, R> extends StateType<InitialS | Versionized<AllS>, T, R> {
    // (undocumented)
    migrate<S1, T1, R1>(nextType: StateType<S1, T1, R1>, migrate: (previousState: S) => S1): MigratableStateType<InitialS, AllS | S1, S1, T1, R1>;
}

// @public (undocumented)
export function number(initialValue?: number): StateType<number, number, {
    value: number;
    get(): number;
    set(value: number | ((currentValue: number) => number)): void;
}>;

// @public (undocumented)
export function object<Ds extends Record<string, StateType>>(types: Ds, getFocusableChildren?: (children: {
    [K in keyof Ds]: {
        id: string;
    }[];
}) => {
    id: string;
}[]): StateType<StateTypesSerializedType<Ds>, StateTypesValueType<Ds>, StateTypesReturnType<Ds>>;

// @public (undocumented)
export function scalar<S>(initialState: S): StateType<S, S, {
    value: S;
    get(): S;
    set(value: S | ((currentValue: S) => S)): void;
}>;

// @public (undocumented)
export function serializedScalar<S, T>(initialState: T, serializer: Serializer<S, T>): StateType<S, T, {
    value: T;
    get(): T;
    set(value: T | ((currentValue: T) => T)): void;
}>;

// @public (undocumented)
export interface Serializer<S, T> {
    // (undocumented)
    deserialize(serialized: S): T;
    // (undocumented)
    serialize(deserialized: T): S;
}

// @public (undocumented)
export function string(initialValue?: string): StateType<string, string, {
    value: string;
    get(): string;
    set(value: string | ((currentValue: string) => string)): void;
}>;

// @public (undocumented)
export interface TempFile {
    // (undocumented)
    failed?: File;
    // (undocumented)
    loaded?: LoadedFile;
    // (undocumented)
    pending?: File;
    // (undocumented)
    uploadHandled?: boolean;
}

// @public (undocumented)
export function upload<T>(defaultState: T): StateType<FileState<T>, FileState<T>, UploadStateReturnType<T>>;

// @public (undocumented)
export type UploadHandler<T> = (file: File) => Promise<T>;

// @public (undocumented)
export interface UploadStateReturnType<T> {
    // (undocumented)
    get(): FileState<T>;
    // (undocumented)
    isPending: boolean;
    // (undocumented)
    set(value: FileState<T> | ((currentValue: FileState<T>) => FileState<T>)): void;
    // (undocumented)
    upload(file: File, handler: UploadHandler<T>): Promise<T>;
    // (undocumented)
    value: FileState<T>;
}

// @public (undocumented)
export type UploadValidator<E = unknown> = (file: File) => {
    valid: true;
} | {
    valid: false;
    errors: E;
};

// @public (undocumented)
export function usePendingFilesUploader<T>(files: UploadStateReturnType<T>[], uploadHandler: UploadHandler<T>): void;

// @public (undocumented)
export function usePendingFileUploader<T>(file: UploadStateReturnType<T>, uploadHandler: UploadHandler<T>): void;

// @public (undocumented)
export interface Versionized<S> {
    // (undocumented)
    __version__: number;
    // (undocumented)
    value: S;
}


export * from "@edtr-io/internal__plugin";
export * from "@edtr-io/internal__plugin-state";

// (No @packageDocumentation comment for this package)

```
