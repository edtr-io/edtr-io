## API Report File for "@edtr-io/plugin"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as InternalPlugin from '@edtr-io/internal__plugin';
import * as InternalPluginState from '@edtr-io/internal__plugin-state';
import * as React_2 from 'react';

// @public (undocumented)
export function asyncScalar<T, Temp>(initial: T, isTemporaryValue: (field: T | Temp) => boolean): AsyncScalarStateType<T, Temp>;

// @public (undocumented)
export type AsyncScalarStateType<T, Temp> = StateType<T, T | Temp, {
    value: T | Temp;
    get(): T | Temp;
    set(initial: T | Temp | ((previousValue: T | Temp) => T | Temp), executor?: StateExecutor<T | Temp | ((previousValue: T | Temp) => T | Temp)>): void;
}>;

// @public (undocumented)
export function boolean(initialValue?: boolean): BooleanStateType;

// @public (undocumented)
export type BooleanStateType = ScalarStateType<boolean>;

// @public (undocumented)
export function child<K extends string, S = unknown>(params: ChildStateTypeConfig): ChildStateType<K, S>;

// @public (undocumented)
export type ChildStateType<K extends string = string, S = unknown> = StateType<{
    plugin: K;
    state?: S;
}, string, {
    get(): string;
    id: string;
    render: (props?: PluginProps) => React_2.ReactElement;
    replace: (plugin: K, state?: S) => void;
}>;

// @public (undocumented)
export interface ChildStateTypeConfig<K extends string = string, S = unknown> {
    // (undocumented)
    config?: {};
    // (undocumented)
    initialState?: S;
    // (undocumented)
    plugin: K;
}

// @public (undocumented)
export type EditorPlugin<S extends StateType = StateType, Config extends {} = {}> = InternalPlugin.EditorPlugin<S, Config>;

// @public (undocumented)
export type EditorPluginProps<S extends StateType = StateType, Config extends {} = {}> = InternalPlugin.EditorPluginProps<S, Config>;

// @public (undocumented)
export type FileState<T> = T | TempFile;

// @public (undocumented)
export type FocusableChild = InternalPluginState.FocusableChild;

// @public (undocumented)
export function isTempFile<T>(state: FileState<T>): state is TempFile;

// @public (undocumented)
export function list<D extends StateType>(type: D, initialCount?: number): ListStateType<D>;

// @public (undocumented)
export type ListStateType<D extends StateType> = StateType<StateTypeSerializedType<D>[], {
    id: string;
    value: StateTypeValueType<D>;
}[], StateTypeReturnType<D>[] & {
    set(updater: (currentList: StateTypeValueType<D>[], deserialize: (serialized: StateTypeSerializedType<D>) => StateTypeValueType<D>) => StateTypeValueType<D>[]): void;
    insert(index?: number, options?: StateTypeSerializedType<D>): void;
    remove(index: number): void;
    move(from: number, to: number): void;
}>;

// @public (undocumented)
export interface LoadedFile {
    // (undocumented)
    dataUrl: string;
    // (undocumented)
    file: File;
}

// @public (undocumented)
export function migratable<S, T, R>(type: StateType<S, T, R>): MigratableStateType<S, S, S, T, R>;

// @public (undocumented)
export interface MigratableStateType<InitialS, AllS, S, T, R> extends StateType<InitialS | Versionized<AllS>, T, R> {
    // (undocumented)
    migrate<S1, T1, R1>(nextType: StateType<S1, T1, R1>, migrate: (previousState: S) => S1): MigratableStateType<InitialS, AllS | S1, S1, T1, R1>;
}

// @public (undocumented)
export function number(initialValue?: number): NumberStateType;

// @public (undocumented)
export type NumberStateType = ScalarStateType<number>;

// @public (undocumented)
export function object<Ds extends Record<string, StateType>>(types: Ds, getFocusableChildren?: (children: {
    [K in keyof Ds]: {
        id: string;
    }[];
}) => {
    id: string;
}[]): ObjectStateType<Ds>;

// @public (undocumented)
export type ObjectStateType<Ds extends Record<string, StateType>> = StateType<StateTypesSerializedType<Ds>, StateTypesValueType<Ds>, StateTypesReturnType<Ds>>;

// @public (undocumented)
export type Optional<T> = {
    defined: true;
    value: T;
} | {
    defined: false;
    value: null;
};

// @public (undocumented)
export function optional<D extends StateType>(type: D, initiallyDefined?: boolean): OptionalStateType<D>;

// @public (undocumented)
export type OptionalStateType<D extends StateType> = StateType<StateTypeSerializedType<D> | undefined, Optional<StateTypeValueType<D>>, {
    defined: false;
    create(value?: StateTypeSerializedType<D>): void;
} | (StateTypeReturnType<D> & {
    defined: true;
    remove(): void;
})>;

// @public (undocumented)
export type PluginProps = InternalPluginState.PluginProps;

// @public (undocumented)
export function scalar<S>(initialState: S): ScalarStateType<S>;

// @public (undocumented)
export type ScalarStateType<S> = SerializedScalarStateType<S, S>;

// @public (undocumented)
export function serializedScalar<S, T>(initialState: T, serializer: Serializer<S, T>): SerializedScalarStateType<S, T>;

// @public (undocumented)
export type SerializedScalarStateType<S, T> = StateType<S, T, {
    value: T;
    get(): T;
    set(value: T | ((currentValue: T) => T), reverse?: (previousValue: T) => T): void;
}>;

// @public (undocumented)
export interface Serializer<S, T> {
    // (undocumented)
    deserialize(serialized: S): T;
    // (undocumented)
    serialize(deserialized: T): S;
}

// @public (undocumented)
export type StateExecutor<T> = InternalPluginState.StateExecutor<T>;

// @public (undocumented)
export type StateType<S = any, T = any, R = any> = InternalPluginState.StateType<S, T, R>;

// @public (undocumented)
export type StateTypeReturnType<D extends StateType> = InternalPluginState.StateTypeReturnType<D>;

// @public (undocumented)
export type StateTypeSerializedType<D extends StateType> = InternalPluginState.StateTypeSerializedType<D>;

// @public (undocumented)
export type StateTypesReturnType<Ds extends Record<string, StateType>> = InternalPluginState.StateTypesReturnType<Ds>;

// @public (undocumented)
export type StateTypesSerializedType<Ds extends Record<string, StateType>> = InternalPluginState.StateTypesSerializedType<Ds>;

// @public (undocumented)
export type StateTypesValueType<Ds extends Record<string, StateType>> = InternalPluginState.StateTypesValueType<Ds>;

// @public (undocumented)
export type StateTypeValueType<D extends StateType> = InternalPluginState.StateTypeValueType<D>;

// @public (undocumented)
export type StateUpdater<T> = InternalPluginState.StateUpdater<T>;

// @public (undocumented)
export type StoreDeserializeHelpers<K extends string = string, S = unknown> = InternalPluginState.StoreDeserializeHelpers<K, S>;

// @public (undocumented)
export type StoreSerializeHelpers<K extends string = string, S = unknown> = InternalPluginState.StoreSerializeHelpers<K, S>;

// @public (undocumented)
export function string(initialValue?: string): StringStateType;

// @public (undocumented)
export type StringStateType = ScalarStateType<string>;

// @public (undocumented)
export interface TempFile {
    // (undocumented)
    failed?: File;
    // (undocumented)
    loaded?: LoadedFile;
    // (undocumented)
    pending?: File;
    // (undocumented)
    uploadHandled?: boolean;
}

// @public (undocumented)
export function upload<T>(defaultState: T): UploadStateType<T>;

// @public (undocumented)
export type UploadHandler<T> = (file: File) => Promise<T>;

// @public (undocumented)
export interface UploadStateReturnType<T> {
    // (undocumented)
    get(): FileState<T>;
    // (undocumented)
    isPending: boolean;
    // (undocumented)
    set(value: FileState<T> | ((currentValue: FileState<T>) => FileState<T>)): void;
    // (undocumented)
    upload(file: File, handler: UploadHandler<T>): Promise<T>;
    // (undocumented)
    value: FileState<T>;
}

// @public (undocumented)
export type UploadStateType<T> = StateType<FileState<T>, FileState<T>, UploadStateReturnType<T>>;

// @public (undocumented)
export type UploadValidator<E = unknown> = (file: File) => {
    valid: true;
} | {
    valid: false;
    errors: E;
};

// @public (undocumented)
export function usePendingFilesUploader<T>(files: UploadStateReturnType<T>[], uploadHandler: UploadHandler<T>): void;

// @public (undocumented)
export function usePendingFileUploader<T>(file: UploadStateReturnType<T>, uploadHandler: UploadHandler<T>): void;

// @public (undocumented)
export interface Versionized<S> {
    // (undocumented)
    __version__: number;
    // (undocumented)
    value: S;
}

// (No @packageDocumentation comment for this package)

```
